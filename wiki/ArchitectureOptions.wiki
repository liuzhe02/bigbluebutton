The goal of this section is to discuss candidate architectures. The structure of the section follows the [ArchitectureCore discussion of what should be at the core of the architecture].

== Collaborative technologies ==

Core should focus on collaborative technologies (not just about voice).

== Plugin architecture ==

Core should be extensible through plugins.

Benefits of a plugin architecture (list started by Paul):

  * Division of core and application
  * Application delivery releases independent of the core
  * Potential items for the BBB store

Michael: The design of the plugin architecture needs account for more than deployment and administration of plugins. In my view, the core issue is to define the extension model: how do plugins extend what exists (core or other plugins), how do the core (or other plugins) define points where the behavior can be extended. If we do not make this our first priority, we end up with a mechanism to define and load modules that does not contribute to a design that is decoupled, easy to understand, and extensible by third-parties without detailed knowledge of the core nor rights to modify the core to accommodate a plugin.

Richard: I agree. I would suggest somebody extract and document interaction between server and client. I have started it here [ClientServerCommunication]. And, also, someone should extract and document all events in the client. Having these list will provide us a good picture of the APIs (client to server, client/UI) and help us design an architecture that is modular, extensible, and flexible.

Michael: Thanks. That is an very helpful document. It provides a map with the major landmarks in the server code. I agree that we should also document the events in the client. We should be able to get a student interested in that. It is well-defined in scope.

Insert description of Extension Object pattern here.

Michael: OSGI appears to address the deployment problem, but does not define an extension model per se. Yes, it helps manage dependencies, but an extension model goes beyond managing dependencies. It provides guidance on how the system can be extended. We also need to identify concrete use scenarios that define what capabilities the extension model should have. As a Java technology, OSGI can be used on the server, but how does it address the need for client-side extensibility?

Insert discussion of OSGI here. How can it be used to deploy and administer plugins? How does it manage plugin dependencies? How can OSGI be applied to the client?

Describe usage scenarios on a page of its own. We want to get input from people working on opportunities.

Michael: There are several existing extension models. For example:
  * Eclipse combines the OSGI deployment model with an extension model that allows plugin authors to expose extension points. An extension point is essentially an interface that the extension needs to implement. The model is capable but complex to implement. 
  * WordPress implements a more straightforward extension model: the WordPress core defines hooks in the code where it can be extended. Extensions can be defined in terms of actions performed at hooks or filters that should be applied to intermediate outputs. 
  * Other systems use an event-based extension model. The core exposes events and defines interfaces that event handlers need to implement. For example, an action such as advancing to the next slide would raise an event that triggers registered extensions.

Insert description of Eclipse extension model here.

Insert description of WordPress-style extension model here.

Insert description of event-based extension model here.

Michael: The third point raised by Paul is an important one. The plugin architecture should allow developers to publish plugins (in some form of marketplace or app store, which is something that Eclipse or WordPress have, in different forms), and users to discover them. The plugin repository (marketplace) would also be a great resource for developers: either to learn or build on top. The second point is also essential. You don't want to tie up the release of the core by plugin release schedules.

== UI separation ==

Core should support different UI delivery mechanisms (such as Flash and HTML5).

== Simplicity ==

Core should focus on unique features that differentiate BigBlueButton. Its simplicity of use is highly valued. Proposed changes to the architecture should be weighed against simplicity of use for end-users as well as developers.

== Migration ==

As the architecture evolves, current !BigBlueButton deployments *must* upgrade seamlessly.

----
[ArchitectureCouncil] [ArchitectureCore]